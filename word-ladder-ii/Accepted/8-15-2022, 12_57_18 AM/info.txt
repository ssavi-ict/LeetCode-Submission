{"id":773691289,"lang":"cpp","lang_name":"C++","time":"4 months, 1 week","timestamp":1660503438,"status":10,"status_display":"Accepted","runtime":"31 ms","url":"/submissions/detail/773691289/","is_pending":"Not Pending","title":"Word Ladder II","memory":"9.4 MB","code":"class Solution {\npublic:\n    \n    /*\n    Step 1: A BFS to connect the nodes or to calculate the level.\n    Step 2: A DFS to populate the result from the destination node. Going downward according to level.\n    */\n    \n    \n    unordered_map<string, int>level;\n    vector< vector<string> >ans;\n    vector<string>temp;\n    \n    void dfs(string src, string dest, int word_sz){\n        temp.push_back(dest);                       // cog , dog-log, dot\n        if(src == dest){\n            vector<string>copyoft = temp;\n            reverse(copyoft.begin(), copyoft.end());\n            ans.push_back(copyoft);\n            temp.pop_back();\n            return;\n        }\n        \n        int level_cur = level[dest];                                              // 4 | 3-3 | 2 | 2\n        for(int i=0; i<word_sz; i++){\n            char x = dest[i];\n            for(char j='a'; j<='z'; j++){\n                dest[i] = j;\n                if(level.find(dest)!=level.end() && level[dest] == level_cur-1){  // dog = 3, log = 3 | dot = 2\n                    dfs(src, dest, word_sz);                                       // dog, log | dot | lot\n                }\n            }\n            dest[i] = x;\n        }\n        \n        temp.pop_back();\n    }\n    \n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n        int n_words = wordList.size();\n        int word_sz = beginWord.size();\n        \n        unordered_map<string, bool>stored;\n        for(int i=0; i<n_words; i++){\n            stored[wordList[i]] = true;\n        }\n        \n        if(!stored[endWord]) return ans;\n                                                        // [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n        \n        queue<string>myQ;                               // hit\n        myQ.push(beginWord);\n        level[beginWord] = 0;\n        while(!myQ.empty()){\n            int q_size = myQ.size();\n            while(q_size--){\n                string top = myQ.front();               // hit, hot, dot\n                int top_level = level[top];             // top_level = 0, top_level = 1, top_level = 2, top_level = 3, top_level = 4\n                myQ.pop()\n                    ;\n                for(int i=0; i<word_sz; i++){\n                    char x = top[i];                    // h, i, t | h, o, t | d, o, t | l, o, t | d, o, g | l, o, g | c, o, g\n                    for(char j='a'; j<='z'; j++){\n                        top[i] = j;                     \n                        if(stored.find(top) != stored.end() && level.find(top) == level.end()){\n                            level[top] = top_level + 1;     // hot = 1, dot = 2, lot = 2, dog = 3, log = 3\n                            myQ.push(top);                  // hot | dot, lot | dog, log | cog\n                        }\n                    }\n                    top[i] = x;\n                }\n            }\n        }\n        \n        dfs(beginWord, endWord, word_sz); // dfs(hit, cog, 3);\n        \n        return ans;\n    }\n};","compare_result":"11111111111111111111111111111111111","title_slug":"word-ladder-ii","has_notes":false,"notes":"","topic_tags":[]}