{"id":777556217,"lang":"cpp","lang_name":"C++","time":"4 months, 1 week","timestamp":1660892594,"status":10,"status_display":"Accepted","runtime":"82 ms","url":"/submissions/detail/777556217/","is_pending":"Not Pending","title":"Split Array into Consecutive Subsequences","memory":"54.5 MB","code":"class Solution {\npublic:\n    \n    int counter[2001], required[2002];\n    \n    bool isPossible(vector<int>& nums) {\n        // unordered_map<int, int>counter;\n        for(int i=0; i<size(nums); i++){\n            counter[nums[i]+1000]++;\n        }\n        // unordered_map<int, int>required;\n        for(int i=0; i<size(nums); i++){\n            if(required[nums[i]+1000] && counter[nums[i]+1000]){\n                required[nums[i]+1000]--;\n                counter[nums[i]+1000]--;\n                required[nums[i]+1+1000]++;\n            }\n            else if(counter[nums[i]+1000] && counter[nums[i]+1+1000] && counter[nums[i]+2+1000]){\n                counter[nums[i]+1000]--;\n                counter[nums[i]+1+1000]--;\n                counter[nums[i]+2+1000]--;\n                required[nums[i]+3+1000]++;\n            }\n            else if(counter[nums[i]+1000]){\n                    return false;\n            }\n        }\n        return true;\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"split-array-into-consecutive-subsequences","has_notes":false,"notes":"","topic_tags":[]}