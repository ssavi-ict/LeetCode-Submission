{"id":846315418,"lang":"cpp","lang_name":"C++","time":"1Â month","timestamp":1668860827,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/846315418/","is_pending":"Not Pending","title":"Erect the Fence","memory":"N/A","code":"class Solution {\npublic:\n\n    int distance(pair<int, int>A, pair<int, int>B, pair<int, int>C){\n        int x1 = A.first - B.first;\n        int x2 = A.first - C.first;\n        int y1 = A.second - B.second;\n        int y2 = A.second - C.second;\n        int distAB = (x1 * x1) + (y1 * y1);\n        int distAC = (x2 * x2) + (y2 * y2);\n        return distAB - distAC;\n    }\n\n    int crossProduct(pair<int, int>A, pair<int, int>B, pair<int, int>C){\n        int x1 = A.first - B.first;\n        int x2 = A.first - C.first;\n        int y1 = A.second - B.second;\n        int y2 = A.second - C.second;\n        int crossProductValue = (x1 * y2) - (x2 * y1);\n        if(crossProductValue == 0) return 0;    // 0 = Co-linear\n        return (crossProductValue > 0) ? 1 : 2;  // 1 = Left, 2 = Right\n    }\n\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\n        int startPoint = 0, n = trees.size();\n        for(int i=1; i<n; i++){\n            if(trees[i][0] < trees[startPoint][0]){\n                startPoint = i;\n            }\n        }\n\n        set<pair<int, int>>ans;\n        vector<pair<int, int>>co_linear(n);\n        ans.insert({trees[startPoint][0], trees[startPoint][1]});\n        \n        int currentPoint = startPoint;\n        while(true){\n            int nextPoint = 0, cl_index = 0;\n            // cout<<currentPoint<<endl;\n            for(int i=1; i<n; i++){\n                if(currentPoint == i) continue;\n                int orientation = crossProduct({trees[currentPoint][0], trees[currentPoint][1]}, {trees[nextPoint][0], trees[nextPoint][1]}, {trees[i][0], trees[i][1]});\n                if(orientation == 1){\n                    nextPoint = i;\n                    cl_index = 0;\n                }\n                else if(orientation == 0){\n                    int col_next = distance({trees[currentPoint][0], trees[currentPoint][1]}, {trees[nextPoint][0], trees[nextPoint][1]}, {trees[i][0], trees[i][1]});\n                    if(col_next < 0){\n                        co_linear[cl_index++] = {trees[nextPoint][0], trees[nextPoint][1]};\n                        nextPoint = i;\n                    }\n                    else{\n                        co_linear[cl_index++] = {trees[i][0], trees[i][1]};\n                    }\n                }\n            }\n            for(int i=0; i<cl_index; i++){\n                ans.insert({co_linear[i].first, co_linear[i].second});\n            }\n            if(nextPoint == startPoint) break;\n            ans.insert({trees[nextPoint][0], trees[nextPoint][1]});\n            currentPoint = nextPoint;\n        }\n        trees.clear();\n        for(auto it : ans){\n            trees.push_back({it.first, it.second});\n        }\n        return trees;\n    }\n};\n\n\n\n\n\n\n\n\n\n\n\n\n","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111110000","title_slug":"erect-the-fence","has_notes":false,"notes":"","topic_tags":[]}