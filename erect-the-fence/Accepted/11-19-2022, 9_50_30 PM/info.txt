{"id":846394075,"lang":"cpp","lang_name":"C++","time":"1Â month","timestamp":1668873030,"status":10,"status_display":"Accepted","runtime":"130 ms","url":"/submissions/detail/846394075/","is_pending":"Not Pending","title":"Erect the Fence","memory":"20.1 MB","code":"class Solution {\npublic:\n\n    int distance(pair<int, int>A, pair<int, int>B, pair<int, int>C){\n        int x1 = A.first - B.first;\n        int x2 = A.first - C.first;\n        int y1 = A.second - B.second;\n        int y2 = A.second - C.second;\n        int distAB = (x1 * x1) + (y1 * y1);\n        int distAC = (x2 * x2) + (y2 * y2);\n        return distAB - distAC;\n    }\n\n    int crossProduct(pair<int, int>A, pair<int, int>B, pair<int, int>C){\n        int x1 = A.first - B.first;\n        int x2 = A.first - C.first;\n        int y1 = A.second - B.second;\n        int y2 = A.second - C.second;\n        int crossProductValue = (x1 * y2) - (x2 * y1);\n        return crossProductValue;\n    }\n\n    vector<vector<int>> outerTrees(vector<vector<int>>& trees) {\n        int startPoint = 0, n = trees.size();\n        for(int i=1; i<n; i++){\n            if(trees[i][0] < trees[startPoint][0]){\n                startPoint = i;\n            }\n        }\n\n        set<pair<int, int>>ans;\n        vector<pair<int, int>>co_linear(n);\n        ans.insert({trees[startPoint][0], trees[startPoint][1]});\n        \n        int currentPoint = startPoint;\n        int count =  n;\n        while(count--){\n            int nextPoint = 0, cl_index = 0;\n            // cout<<currentPoint<<endl;\n            for(int i=1; i<n; i++){\n                if(currentPoint == i) continue;\n                int cpValue = crossProduct({trees[currentPoint][0], trees[currentPoint][1]}, {trees[nextPoint][0], trees[nextPoint][1]}, {trees[i][0], trees[i][1]});\n                if(cpValue > 0){\n                    nextPoint = i;\n                    cl_index = 0;\n                }\n                else if(cpValue == 0){\n                    int col_next = distance({trees[currentPoint][0], trees[currentPoint][1]}, {trees[nextPoint][0], trees[nextPoint][1]}, {trees[i][0], trees[i][1]});\n                    if(col_next < 0){\n                        co_linear[cl_index++] = {trees[nextPoint][0], trees[nextPoint][1]};\n                        nextPoint = i;\n                    }\n                    else{\n                        co_linear[cl_index++] = {trees[i][0], trees[i][1]};\n                    }\n                }\n            }\n            for(int j=0; j<cl_index; j++){\n                ans.insert({co_linear[j].first, co_linear[j].second});\n            }\n            if(nextPoint == startPoint) break;\n            ans.insert({trees[nextPoint][0], trees[nextPoint][1]});\n            currentPoint = nextPoint;\n        }\n        trees.clear();\n        for(auto it : ans){\n            trees.push_back({it.first, it.second});\n        }\n        return trees;\n    }\n};\n\n\n\n\n\n\n\n\n\n\n\n\n","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"erect-the-fence","has_notes":false,"notes":"","topic_tags":[]}