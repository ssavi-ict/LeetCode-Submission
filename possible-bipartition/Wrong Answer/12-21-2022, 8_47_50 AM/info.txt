{"id":862989187,"lang":"cpp","lang_name":"C++","time":"3 days, 9 hours","timestamp":1671590870,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/862989187/","is_pending":"Not Pending","title":"Possible Bipartition","memory":"N/A","code":"class Solution {\npublic:\n\n    bool dfs(int src, vector<vector<int>>&graph, vector<int>&visited, int color){\n        visited[src] = color;\n        bool status = true;\n        for(int i=0; i<graph[src].size(); i++){\n            int child = graph[src][i];\n            if(visited[child] != -1) status = status & false;\n            status = status & dfs(child, graph, visited, color ^ 1);\n        }\n        return status;\n    }\n\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        vector<vector<int>>graph(n+1);\n        int dis_size = dislikes.size();\n        for(int i=0; i<dis_size; i++){\n            graph[dislikes[i][0]].push_back(dislikes[i][1]);\n            // graph[dislikes[i][1]].push_back(dislikes[i][0]);\n        }\n        vector<int>visited(n+1, -1);\n        return dfs(1, graph, visited, 0);\n    }\n};","compare_result":"1111111010110111010101010101010101010101010101010100000000000000000000","title_slug":"possible-bipartition","has_notes":false,"notes":"","topic_tags":[]}