{"id":767847839,"lang":"cpp","lang_name":"C++","time":"4 months, 2 weeks","timestamp":1659901642,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/767847839/","is_pending":"Not Pending","title":"Find Leaves of Binary Tree","memory":"9 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    \n    int solve(TreeNode * root, vector< vector<int>>&ans){\n        if(!root) return 0;\n        int lvl = max(solve(root->left, ans), solve(root->right, ans)) + 1;\n        if(lvl > ans.size()) ans.push_back(vector<int>());\n        ans[lvl-1].push_back(root->val);\n        return lvl;\n    }\n    \n    vector<vector<int>> findLeaves(TreeNode* root) {\n        vector< vector<int>> ans;\n        solve(root, ans);\n        return ans;\n    }\n};\n\n/*\n\nsolve(1, ans) -> max(solve(2), solve(3))\nmax(solve(2), solve(3)) -> solve(2) -> max(solve(4), solve(5))\nsolve(4) = 0 + 1 = 1 | solve(5) = 0 + 1 = 1 =>  ans[0]-> 4, 5, 3\nsolve(2) = max(solve(4), solve(5)) + 1 = 1 + 1 = 2 => ans[1]->2\nsolve(3) = max(0, 0) + 1 = 1 => ans[0]-> 4, 5, 3\nsolve(1) = max(2, 1) + 1 = 3 => ans[2]->1\n*/","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-leaves-of-binary-tree","has_notes":false,"notes":"","topic_tags":[]}