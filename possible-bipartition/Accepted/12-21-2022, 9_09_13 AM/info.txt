{"id":862996353,"lang":"cpp","lang_name":"C++","time":"3 days, 9 hours","timestamp":1671592153,"status":10,"status_display":"Accepted","runtime":"263 ms","url":"/submissions/detail/862996353/","is_pending":"Not Pending","title":"Possible Bipartition","memory":"64.6 MB","code":"class Solution {\npublic:\n\n    bool dfs(int src, vector<vector<int>>&graph, vector<int>&visited, int color){\n        visited[src] = color;\n        bool status = true;\n        for(int i=0; i<graph[src].size(); i++){\n            int child = graph[src][i];\n            if(visited[child] != -1 && visited[child] == color) status = status & false;\n            if(visited[child] == -1) status = status & dfs(child, graph, visited, color ^ 1);\n        }\n        return status;\n    }\n\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        vector<vector<int>>graph(n+1);\n        int dis_size = dislikes.size();\n        for(int i=0; i<dis_size; i++){\n            graph[dislikes[i][0]].push_back(dislikes[i][1]);\n            graph[dislikes[i][1]].push_back(dislikes[i][0]);\n        }\n        \n        vector<int>visited(n+1, -1);\n        for(int i=1; i<=n; i++){\n            if(visited[i] == -1){\n                if(!dfs(i, graph, visited, 0)) return false;\n            }\n        }\n        return true;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"possible-bipartition","has_notes":false,"notes":"","topic_tags":[]}