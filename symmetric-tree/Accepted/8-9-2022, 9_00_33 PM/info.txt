{"id":769408267,"lang":"cpp","lang_name":"C++","time":"4 months, 2 weeks","timestamp":1660057233,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/769408267/","is_pending":"Not Pending","title":"Symmetric Tree","memory":"18.7 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<pair<int, char>>store[1001];  // Left = 'l', Right = 'r'\nint mxlvl;\n\nvoid solve(TreeNode * root, int lvl, char direction){\n  if(!root){\n    store[lvl].push_back(make_pair(1001, 'n'));\n    return;\n  }\n  mxlvl = max(mxlvl, lvl);\n  if(direction == 'l' || direction=='r'){\n    store[lvl].push_back(make_pair(root->val, direction));\n  }\nsolve(root->left, lvl+1, 'l');\nsolve(root->right, lvl+1, 'r');\n  \n}\n\nbool isSymmetric(TreeNode* root) {\n  mxlvl = 0;\n  solve(root, 0, 'a');\n  for(int i=1; i<=mxlvl; i++){\n    int size = store[i].size();\n    if(size%2) return false;\n    for(int j=0; j<size/2; j++){\n      int val = store[i][j].first, rev = store[i][size-j-1].first;\n      char ore1 = store[i][j].second, ore2 = store[i][size-j-1].second;\n      if(ore1 == 'n' && ore2=='n'){\n        ;\n      }\n      else if(ore1=='l' && ore2=='r' && val==rev){\n        ;\n      }\n      else if(ore1=='r' && ore2=='l' && val==rev){\n        ;\n      }\n      else return false;\n    }\n  }\n  return true;\n}\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"symmetric-tree","has_notes":false,"notes":"","topic_tags":[]}